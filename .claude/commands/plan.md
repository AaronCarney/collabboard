# /plan — Feature Planning Command

**Usage:** `/plan <feature-name or path to spec file>`

**Example:** `/plan canvas-object-rendering` or `/plan docs/specs/cursor-sync.md`

---

## Process

When invoked, follow these 5 steps:

### Step 1: Read the Spec

Read `docs/specs/<feature-name>.md`. If it doesn't exist, say so and stop — do not plan without a spec.

Extract:

- Acceptance criteria (these become test cases)
- Out-of-scope items
- Dependencies on other features
- Performance requirements

### Step 2: Identify Dependencies

List:

- Existing code that will be modified
- New packages required (verify they exist on npm before including)
- Database schema changes needed
- Environment variables required

### Step 3: Break into Implementation Phases

Phases must follow this order:

1. **Schema/Types** — Database migrations, Zod schemas, TypeScript types (in `packages/shared`)
2. **Backend** — tRPC procedures, Durable Object handlers, server utilities
3. **Frontend** — React components, hooks, Canvas rendering
4. **Tests** — Unit tests, integration tests, E2E tests (generated by @test-writer)
5. **Integration** — Wire frontend to backend, verify E2E, performance test if needed

Each phase should produce a deployable (or at least mergeable) state. No phase should leave the codebase broken.

### Step 4: Identify Test Cases

For each acceptance criterion, list:

- One happy-path test
- One error/edge case test
- Performance test if latency budget applies

### Step 5: Identify Risks

List any:

- Ambiguity in the spec (needs human clarification)
- Architectural decisions that conflict with invariants
- External service dependencies that could block progress
- Performance risks against defined budgets

---

## Output Format

Save to `docs/plans/<feature-name>.md`:

```
## Plan: <Feature Name>

**Source spec:** docs/specs/<feature-name>.md

### Acceptance Criteria (from spec)
- [ ] AC1: <criterion>
- [ ] AC2: <criterion>

### New Dependencies
- `<package-name>@<version>` — <purpose> (verify exists: `npm view <package>`)

### Database Changes
- <table>: add column <name> <type> — <purpose>
- Migration file: `packages/db/prisma/migrations/<timestamp>_<name>.sql`

### Implementation Phases

#### Phase 1: Schema & Types
**Commit:** `feat(<package>): add <feature> types and Zod schemas`
- [ ] <task 1>
- [ ] <task 2>

#### Phase 2: Backend
**Commit:** `feat(api): implement <feature> tRPC procedures`
- [ ] <task>

#### Phase 3: Frontend
**Commit:** `feat(web): add <feature> UI components`
- [ ] <task>

#### Phase 4: Tests
**Commit:** `test(<package>): add <feature> unit and integration tests`
- [ ] Invoke @test-writer: "Write failing tests for <feature> based on docs/specs/<feature-name>.md"
- [ ] Verify all tests fail before implementation

#### Phase 5: Integration
**Commit:** `feat(<feature>): complete integration and verify all acceptance criteria`
- [ ] Wire frontend to backend
- [ ] Run `pnpm typecheck && pnpm lint && pnpm test && pnpm build`
- [ ] Run load test if latency-sensitive

### Risks
- <risk 1> — <mitigation>

### Human Review Required
- [ ] Auth/permissions changes — human reads diff before merge
- [ ] Database schema changes — DBA review if applicable
- [ ] New external service — security review
```
